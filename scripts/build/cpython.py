import json
import os
import pathlib
import platform
import random
import subprocess
import sys


BANNER: str = "\n".join([
    "\"\"\"",
    "# This file is automatically generated by the build script.",
    "# Do not modify this file -- YOUR CHANGES WILL BE ERASED!",
    "\"\"\"",
])


def is_supported_platform() -> bool:
    return platform.system() in (
        "Darwin",
        "Linux",
        "Windows",
    )


def is_cpython() -> bool:
    return platform.python_implementation() == "CPython"


def python_version() -> tuple[int, int]:
    major: int = sys.version_info.major
    minor: int = sys.version_info.minor
    return (major, minor)


def is_supported_python_version():
    return python_version() >= (3, 9)


def is_windows() -> bool:
    return platform.system() == "Windows"


def sysroot() -> pathlib.Path:
    return pathlib.Path("C:/" if is_windows() else "/")


def descent(path: pathlib.Path, depth: int) -> pathlib.Path:
    for _ in range(depth):
        path = path.parent
    return path


def muskox_root() -> pathlib.Path:
    script = pathlib.Path(__file__).resolve()
    return descent(script, depth=3)


def bazel_execroot() -> pathlib.Path:
    command: str = "bazel info output_base"

    process = subprocess.run(
        args=command,
        shell=True,
        stdin=subprocess.DEVNULL,
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE,
        universal_newlines=True,
    )

    stdout: str = process.stdout
    path = pathlib.Path(stdout)

    return path.parent


def is_bazel_cache(path: str | os.PathLike) -> bool:
    root: pathlib.Path = muskox_root()
    path = pathlib.Path(path)
    return any([
        root / "bazel-bin" in path.parents,
        root / "bazel-muskox" in path.parents,
        root / "bazel-out" in path.parents,
        root / "bazel-testlogs" in path.parents,
    ])


def is_bazel_execroot(path: str | os.PathLike) -> bool:
    return bazel_execroot() in pathlib.Path(path).parents


def find(path: str | os.PathLike) -> list[pathlib.Path]:
    pattern: str = pathlib.Path(path).as_posix()
    return [
        some_path
        for some_path in sysroot().rglob(pattern)
        if some_path.as_posix().endswith(pattern)
    ]


def get_srcs_pattern() -> str:
    major, minor = python_version()

    if is_windows():
        return f"libs/python{major}{minor}.lib"

    return "/".join([
        f"lib/python{major}.{minor}",
        f"config-{major}.{minor}*",
        f"libpython{major}.{minor}.so",
    ])


def main():
    if pathlib.Path.cwd() != muskox_root():
        raise RuntimeError("The script must be run from the 'muskox' root")

    if not is_supported_platform():
        raise RuntimeError("The OS is not supported")

    if not is_supported_python_version():
        major, minor = python_version()
        raise RuntimeError(f"Python {major}.{minor} is not supported")

    if not is_cpython():
        raise RuntimeError("The interpreter is not CPython")

    major, minor = python_version()

    pattern = pathlib.Path("include")
    root_depth: int = 1

    if is_windows():
        pattern /= "Python.h"
        root_depth += 1

    else:
        pattern /= f"python{major}.{minor}/Python.h"
        root_depth += 2

    python_h_headers = list(filter(
        lambda path: not any([
            is_bazel_cache(path),
            is_bazel_execroot(path),
        ]),
        find(pattern),
    ))

    if not python_h_headers:
        raise RuntimeError("The script did not detect any 'Python.h' file")

    suitable_roots = []

    for python_h in python_h_headers:
        root: pathlib.Path = descent(python_h, root_depth)

        pattern: str = get_srcs_pattern()
        srcs = list(root.glob(pattern))

        if len(srcs) == 1:
            suitable_roots.append(root)

    if not suitable_roots:
        raise RuntimeError("The script did not detect suitable CPython root")

    cpython_root: pathlib.Path = random.choice(suitable_roots)
    include_directory = pathlib.Path("include")

    if not is_windows():
        include_directory /= f"python{major}.{minor}"

    includes = [
        include_directory,
        include_directory.joinpath("cpython"),
        include_directory.joinpath("internal"),
    ]

    pattern: str = f"{include_directory.as_posix()}/**/*.h"
    hdrs = cpython_root.glob(pattern)

    pattern: str = get_srcs_pattern()
    srcs = cpython_root.glob(pattern)

    srcs = [
        path.relative_to(cpython_root).as_posix()
        for path in srcs
    ]

    hdrs = [
        path.relative_to(cpython_root).as_posix()
        for path in hdrs
    ]

    includes = [
        directory.as_posix()
        for directory in includes
    ]

    env: str = "\n".join([
        BANNER,
        "",
        f"ROOT = \"{cpython_root.as_posix()}\"",
        "",
        f"SRCS = {json.dumps(srcs, indent=4)}",
        "",
        f"HDRS = {json.dumps(hdrs, indent=4)}",
        "",
        f"INCLUDES = {json.dumps(includes, indent=4)}",
        "",
    ])

    with open("bazel/env/cpython.bzl", mode="w") as file:
        file.write(env)


if __name__ == "__main__":
    main()
